import json
import re
import os
import sys

import dockers


class Spec(dict):

    def __init__(self, *args, **kwargs):
        self.dockers = kwargs.pop('dockers')
        super(Spec, self).__init__(*args, **kwargs)

    def _find_file(self, name):
        for n, schema in self['schemas'].iteritems():
            if name in n:
                return schema
        return {}

    # endpoint is currently unused
    @property
    def endpoints(self):
        return self.dockers.endpoints

    def match_endpoint(self, name):
        return self.dockers.match_endpoint(name)

    # errors is currently unused
    @property
    def errors(self):
        return self.dockers.errors

    # views is unused in rev1
    @property
    def views(self):
        return self.dockers.view

    def match_view(self, name):
        print('Getting view: ', name)
        return self.dockers.match_view(name)

    # only used for audit events
    @property
    def enums(self):
        return self.dockers.enums

    def match_enum(self, name):
        return self.dockers.match_enum(name)

    # used on some resources
    # currently not documented in balanced-api
    @property
    def queries(self):
        return self.dockers.queries

    def match_query(self, name):
        return self.dockers.match_query(name)

    # this is the big one, lots of
    # @property
    # def forms(self):
    #     return self.dockers.forms

    def generate_key_set(self, request, resource):
        if request['request']:
            if resource in request['request']:
                keys = set(request['request'][resource][0].keys())
            else:
                keys = set(request['request'].keys())
        else:
            keys = set({})
        return keys

    def nullable_key_set(self, request, resource):
        nullable_keys = set()
        if request['request']:
            if resource in request['request']:
                for key, val in request['request'][resource][0].iteritems():
                    if val is None:
                        nullable_keys.add(key)
            else:
                for key, val in request['request'].iteritems():
                    if val is None:
                        nullable_keys.add(key)
        return nullable_keys

    def remove_ignored_keys(self, key_set):
        ignored_keys = ["bank_accounts_id", "credits_id", "cards_id",
                        "debits_id", "customers_id", "customers_source",
                        "orders_id"]
        try:
            for key in ignored_keys:
                key_set.remove(key)
        except KeyError:
            pass

    def match_form(self, name):
        resource, action = name.split('.')

        # HAX, holds is coming in from somewhere
        resource = {
            'holds': 'card_holds'
        }.get(resource, resource)

        if action == 'create':
            reqs = self['resources_create'][resource]
        else:
            reqs = self['resources_update'][resource]
        view = self._find_file('_models/{}.json'.format(resource[:-1]))

        # keys will only be required on create
        # this first request sets baseline for required keys
        required = self.generate_key_set(reqs[0], resource)

        all_keys = set(required)
        nullable = set()

        # cycle through all requests to collect all potential keys
        for r in reqs:
            keys = self.generate_key_set(r, resource)
            # if the key is in all requests then it is required
            required = required.intersection(keys)
            # basically merge the names of all the keys
            all_keys.update(keys)

            nullable_keys = self.nullable_key_set(r, resource)
            nullable = set(list(nullable) + list(nullable_keys))

        # remove ignored keys generated by api-spec
        for key_set in [required, all_keys, nullable]:
            self.remove_ignored_keys(key_set)

        def get_description(view, name):
            try:
                description = view['properties'].get(name, {}).get('description')
            except:
                description = None

            if description is None:
                try:
                    description = (
                        view['properties']
                        .get('links', {}).get('properties', {})
                        .get(name, {}).get('description')
                    )
                except:
                    description = None

            return description

        def get_type(name):
            disallowed_types = ['null']
            field_types = view['properties'].get(name, {}).get('type')
            if type(field_types) is list:
                for t in field_types:
                    if t not in disallowed_types:
                        return t
            return field_types or 'string'

        def generate_form(resource, action):
            fields = []
            for name in all_keys:
                field = {}
                ignored_object_keys = ['links']
                if get_type(name) == 'object':# and name not in ignored_object_keys:
                    resource_model = self._find_file('_models/{}.json'.format(name))
                    subkeys = set()
                    subfields = []

                    for r in reqs:
                        if r['request']:
                            if resource in r['request']:
                                keys = r['request'][resource][0].keys()
                                if name in r['request'][resource][0]:
                                    for key, val in r['request'][resource][0][name].iteritems():
                                        subkeys.add(key)
                            else:
                                keys = r['request'].keys()
                                if name in r['request']:
                                    for key, val in r['request'][name].iteritems():
                                        subkeys.add(key)
                        else:
                            keys = {}

                    for sk in subkeys:
                        descr = get_description(resource_model, sk)
                        if not descr:
                            continue

                        subfield = {
                            'name': sk,
                            'description': descr,
                            'nullable': sk in nullable,
                            'required': sk in required,
                            'tags': [],
                            'type': get_type(sk),
                            'validate': None
                        }
                        subfields.append(subfield)

                    field = {
                        'form': {
                            'fields': subfields,
                            'type': 'form',
                            'name': '{}_{}_form'.format(name, action),
                            'tags': []
                        },
                        'tags': [],
                        'nullable': name in nullable,
                        'required': name in required,
                        'validate': None,
                        'type': 'form_field' if subfields else 'object',
                        'description': get_description(view, name),
                        'name': name
                    }
                else:
                    field = {
                        'name': name,
                        'description': get_description(view, name),
                        'nullable': name in nullable,
                        'required': name in required,
                        'tags': [],
                        'type': get_type(name),
                        'validate': None
                    }
                fields.append(field)

            def fields_sort(a, b):
                if a['required'] and not b['required']:
                    return -1
                if not a['required'] and b['required']:
                    return 1
                return 0

            fields.sort(key=lambda x: x['name'])
            fields.sort(cmp=fields_sort)

            return {
                'fields': fields,
                'type': 'form',
                'name': '{}_{}_form'.format(resource, action)
            }

        return generate_form(resource, action)
